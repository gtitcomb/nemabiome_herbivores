panel.grid = element_blank(), panel.border = element_rect(color = "black",
fill = NA))
p2 <- ggplot(data = si_output_melted) + geom_line(aes(x = time, y = value,
col = variable), size=2, alpha=0.3) + scale_color_manual(breaks = c("w=6mo", "w=1yr","w=5yrs", "w=10yrs"), labels = c("w=6mo", "w=1yr","w=5yrs", "w=10yrs"),
values = c("skyblue","blue2", "darkblue", "black")) + labs(x = "Time",
y = "Number of individuals", col = "State") + theme(panel.background = element_blank(),
panel.grid = element_blank(), panel.border = element_rect(color = "black",
fill = NA)) +scale_y_continuous(limits=c(0,100))
grid.arrange(p1,p2)
# Define state variables and initial conditions
init <- c(S = 999, I = 1, R = 0, cum_new_infections = 0)
# Define parameters
params <- c(c = 4, rho = 0.2, nu = 1/14, f_s= (1/(50*365))*(1-0.8), f_r=(1/(50*365))*0.8, m = 1/(50*365), protect = 1, w=1/(2*365))
# Define length of simulation and output steps
t <- seq(0, 500, 1)
# Define function
fx_sis_bd <- function(t, y, params) {
with(c(as.list(y), params), {
# Define population size
N <- S + I + R
# Define differential equations
dS <- (f_s * N) + (f_r*N)*(1-protect) - (S * I/N * c * rho) - (m * S) + (w*R)
dI <- (S * I/N * c * rho) - (I * nu) - (m * I)
dR <- (f_r * N)*(protect) + (I * nu) - (m * R) - (w*R)
# Calculate number of new infections
cum_new_infections <- c * rho * S * I/N
# Specify output to be returned by function
list(c(dS, dI, dR, cum_new_infections))
})
}
# Call lsoda function with initial conditions, times, SI
# function, and parameters defined above.
si_output <- as.data.table(lsoda(y = init, times = t, func = fx_sis_bd,
parms = params))
# Melt dataset for easy plotting
si_output_melted <- melt(data = si_output, id.vars = "time",
measure.vars = c("S","I", "R"))
ggplot(data = si_output_melted) + geom_line(aes(x = time, y = value,
col = variable), size=2, alpha=0.3) + scale_color_manual(breaks = c("S", "I", "R"), labels = c("Susceptible", "Infected", "Recovered"),
values = c("green", "red", "gray")) + labs(x = "Time",
y = "Number of individuals", col = "State") + theme(panel.background = element_blank(),
panel.grid = element_blank(), panel.border = element_rect(color = "black",
fill = NA))
# 5 year waning immunity
params[8] <- 1/(5*365)
si_output3 <- as.data.table(lsoda(y = init, times = t, func = fx_sis_bd,
parms = params))
# 10 year
params[8] <- 1/(10*365)
si_output4 <- as.data.table(lsoda(y = init, times = t, func = fx_sis_bd,
parms = params))
# 1 year
params[8] <- 1/(1*365)
si_output2 <- as.data.table(lsoda(y = init, times = t, func = fx_sis_bd,
parms = params))
# 6 months
params[8] <- 1/(0.5*365)
si_output1 <- as.data.table(lsoda(y = init, times = t, func = fx_sis_bd,
parms = params))
infs <- as.data.frame(cbind(si_output1$time, si_output1$I, si_output2$I, si_output3$I, si_output4$I))
names(infs) <- c("time", "w=6mo", "w=1yr","w=5yrs", "w=10yrs")
si_output_melted <- melt(data = infs, id.vars = "time",
measure.vars = c("w=6mo", "w=1yr","w=5yrs", "w=10yrs"))
p1 <- ggplot(data = si_output_melted) + geom_line(aes(x = time, y = value,
col = variable), size=2, alpha=0.3) + scale_color_manual(breaks = c("w=6mo", "w=1yr","w=5yrs", "w=10yrs"), labels = c("w=6mo", "w=1yr","w=5yrs", "w=10yrs"),
values = c("skyblue","blue2", "darkblue", "black")) + labs(x = "Time",
y = "Number of individuals", col = "State") + theme(panel.background = element_blank(),
panel.grid = element_blank(), panel.border = element_rect(color = "black",
fill = NA))
p2 <- ggplot(data = si_output_melted) + geom_line(aes(x = time, y = value,
col = variable), size=2, alpha=0.3) + scale_color_manual(breaks = c("w=6mo", "w=1yr","w=5yrs", "w=10yrs"), labels = c("w=6mo", "w=1yr","w=5yrs", "w=10yrs"),
values = c("skyblue","blue2", "darkblue", "black")) + labs(x = "Time",
y = "Number of individuals", col = "State") + theme(panel.background = element_blank(),
panel.grid = element_blank(), panel.border = element_rect(color = "black",
fill = NA)) +scale_y_continuous(limits=c(0,100))
grid.arrange(p1,p2)
# plots
ggplot(data = si_output_melted) + geom_line(aes(x = time, y = value,
col = variable), size=2, alpha=0.3) + scale_color_manual(breaks = c("I_0", "I_50","I_95"), labels = c("0%", "50%", "95%"),
values = c("red", "orange", "green")) + labs(x = "Time",
y = "Number of individuals", col = "Uptake") + theme(panel.background = element_blank(),
panel.grid = element_blank(), panel.border = element_rect(color = "black",
fill = NA))
# Scenario 1 - 0% uptake:
params <- c(c = 4, rho = 0.2, nu = 1/7, f_s= 0.01*1, f_r=0.01*0, m = 0.01, rate = 1/8)
si_output1 <- as.data.table(lsoda(y = init, times = t, func = fx_sis_bd,
parms = params))
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(deSolve)
library(data.table)
library(gridExtra)
library(knitr)
# Define state variables and initial conditions
init <- c(S = 1000, E = 0, I = 1, R = 0, cum_new_infections = 0)
# Define parameters
params <- c(c = 4, rho = 0.2, nu = 1/7, f_s= (0.01)/2, f_r=(0.01)/2, m = 0.01, rate = 1/8)
# Define length of simulation and output steps
t <- seq(0, 500, 1)
# Define function
fx_sis_bd <- function(t, y, params) {
with(c(as.list(y), params), {
# Define population size
N <- S + E + I + R
# Define differential equations
dS <- (f_s * N) - (S * I/N * c * rho) - (m * S)
dE <- -(E*rate) - (m*E) + (S*c*rho*I/N)
dI <- (E * rate) - (I * nu) - (m * I)
dR <- (f_r * N) + (I * nu) - (m * R)
# Calculate number of new infections
cum_new_infections <- c * rho * S * I/N
# Specify output to be returned by function
list(c(dS, dE, dI, dR, cum_new_infections))
})
}
# Call lsoda function with initial conditions, times, SI
# function, and parameters defined above.
si_output <- as.data.table(lsoda(y = init, times = t, func = fx_sis_bd,
parms = params))
# Melt dataset for easy plotting
si_output_melted <- melt(data = si_output, id.vars = "time",
measure.vars = c("S", "E","I", "R"))
ggplot(data = si_output_melted) + geom_line(aes(x = time, y = value,
col = variable), size=2, alpha=0.3) + scale_color_manual(breaks = c("S", "E","I", "R"), labels = c("Susceptible", "Exposed", "Infected", "Recovered"),
values = c("green", "orange", "red", "gray")) + labs(x = "Time",
y = "Number of individuals", col = "State") + theme(panel.background = element_blank(),
panel.grid = element_blank(), panel.border = element_rect(color = "black",
fill = NA))
# R0 is p * c / nu
(r0 <- 0.2*4*7)
# HIT is Herd Immunity Threshold = (R0-1)/R0
(r0-1)/r0
# Scenario 1 - 0% uptake:
params <- c(c = 4, rho = 0.2, nu = 1/7, f_s= 0.01*1, f_r=0.01*0, m = 0.01, rate = 1/8)
si_output1 <- as.data.table(lsoda(y = init, times = t, func = fx_sis_bd,
parms = params))
# Scenario 2 - 50% uptake:
params[4] <- (0.01)*0.5
params[5] <- (0.01)*0.5
si_output2 <- as.data.table(lsoda(y = init, times = t, func = fx_sis_bd,
parms = params))
# Scenario 3 - 95% uptake:
params[4] <- (0.01)*0.05
params[5] <- (0.01)*0.95
si_output3 <- as.data.table(lsoda(y = init, times = t, func = fx_sis_bd,
parms = params))
dfbind <- as.data.frame(cbind(si_output1$time,si_output1$I,si_output2$I,si_output3$I))
names(dfbind) <- c("time", "I_0", "I_50", "I_95")
# Melt dataset for easy plotting
si_output_melted <- melt(data = dfbind, id.vars = "time",
measure.vars = c("I_0", "I_50","I_95"))
# plots
ggplot(data = si_output_melted) + geom_line(aes(x = time, y = value,
col = variable), size=2, alpha=0.3) + scale_color_manual(breaks = c("I_0", "I_50","I_95"), labels = c("0%", "50%", "95%"),
values = c("red", "orange", "green")) + labs(x = "Time",
y = "Number of individuals", col = "Uptake") + theme(panel.background = element_blank(),
panel.grid = element_blank(), panel.border = element_rect(color = "black",
fill = NA))
ggplot(data = si_output) +
geom_line(aes(x = time, y = c(0,diff(cum_new_infections))), size=2, alpha=0.3) +
labs(x = "Time", y = "Number of individuals", col = "") +
theme(panel.background = element_blank(), panel.grid = element_blank(), panel.border = element_rect(color = "black",
fill = NA))
# Define state variables and initial conditions
init <- c(S_u = 999, S_v=0, I = 1, R = 0, cum_new_infections = 0)
# Define parameters
params <- c(c = 4, rho = 0.2, nu = 0.2, f_s= 0.01*(1-0.8), f_r=0.01*0.8, m = 0.01, efficacy = 0.8)
# Define length of simulation and output steps
t <- seq(0, 1000, 1)
# Define function
fx_sis_bd <- function(t, y, params) {
with(c(as.list(y), params), {
# Define population size
N <- S_u + S_v + I + R
# Define differential equations
dS_u <- (f_s * N) - (S_u * I/N * c * rho) - (m * S_u)
dS_v <- (f_r * N) - (S_v * I/N * c * rho * (1-efficacy)) - (m * S_v)
dI <- (S_u * I/N * c * rho)+(S_v * I/N * c * rho * (1-efficacy)) - (I * nu) - (m * I)
dR <- (I * nu) - (m * R) + (f_r * N * efficacy)
# Calculate number of new infections
cum_new_infections <- (c * rho * S_u * I/N)+(c*rho*S_v*I/N*(1-efficacy))
# Specify output to be returned by function
list(c(dS_u,dS_v, dI, dR, cum_new_infections))
})
}
# Call lsoda function with initial conditions, times, SI
# function, and parameters defined above.
si_output <- as.data.table(lsoda(y = init, times = t, func = fx_sis_bd,
parms = params))
# Melt dataset for easy plotting
si_output_melted <- melt(data = si_output, id.vars = "time",
measure.vars = c("S_u","S_v","I", "R"))
ggplot(data = si_output_melted) + geom_line(aes(x = time, y = value,
col = variable), size=2, alpha=0.3) + scale_color_manual(breaks = c("S_u","S_v", "I", "R"), labels = c("Susceptible_u", "Susceptible_v", "Infected", "Recovered"),
values = c("green", "darkgreen", "red", "gray")) + labs(x = "Time",
y = "Number of individuals", col = "State") + theme(panel.background = element_blank(),
panel.grid = element_blank(), panel.border = element_rect(color = "black",
fill = NA))
# Define state variables and initial conditions
init <- c(S_u = 999, S_v=0, I = 1, R = 0, cum_new_infections = 0)
# Define parameters
params <- c(c = 4, rho = 0.2, nu = 0.2, f_s= 0.01*(1-0.8), f_r=0.01*0.8, m = 0.01, efficacy = 0.8)
# Define length of simulation and output steps
t <- seq(0, 1000, 1)
# Define function
fx_sis_bd <- function(t, y, params) {
with(c(as.list(y), params), {
# Define population size
N <- S_u + S_v + I + R
# Define differential equations
dS_u <- (f_s * N) - (S_u * I/N * c * rho) - (m * S_u)
dS_v <- (f_r * N) - (S_v * I/N * c * rho * (1-efficacy)) - (m * S_v)
dI <- (S_u * I/N * c * rho)+(S_v * I/N * c * rho * (1-efficacy)) - (I * nu) - (m * I)
dR <- (I * nu) - (m * R)
# Calculate number of new infections
cum_new_infections <- (c * rho * S_u * I/N)+(c*rho*S_v*I/N*(1-efficacy))
# Specify output to be returned by function
list(c(dS_u,dS_v, dI, dR, cum_new_infections))
})
}
# Call lsoda function with initial conditions, times, SI
# function, and parameters defined above.
si_output <- as.data.table(lsoda(y = init, times = t, func = fx_sis_bd,
parms = params))
# Melt dataset for easy plotting
si_output_melted <- melt(data = si_output, id.vars = "time",
measure.vars = c("S_u","S_v","I", "R"))
ggplot(data = si_output_melted) + geom_line(aes(x = time, y = value,
col = variable), size=2, alpha=0.3) + scale_color_manual(breaks = c("S_u","S_v", "I", "R"), labels = c("Susceptible_u", "Susceptible_v", "Infected", "Recovered"),
values = c("green", "darkgreen", "red", "gray")) + labs(x = "Time",
y = "Number of individuals", col = "State") + theme(panel.background = element_blank(),
panel.grid = element_blank(), panel.border = element_rect(color = "black",
fill = NA))
setwd("D:/Dropbox/Classes")
levelplot(as.matrix(otu_sparse2[,15:73]), xlab="Sample", ylab="OTU", pretty=T, col.regions=colorRampPalette(c("darkblue","white","pink")), scales = list(tck = c(1,0)))
head(otu_sparse2)
head(otu_sparse2)
names(otu_sparse2)
aggregate(.~Species,data=otu_sparse2[,c(11,15:73)], FUN=mean)
assoc <- aggregate(.~Species,data=otu_sparse2[,c(11,15:73)], FUN=mean)
colSums(assoc)
head(assoc)
levels(otu$Location)
nems <- read.table("OTU_log3.5.tab", header=T)
dim(nems)
head(nems)
nems3 <- read.table("OTU_log3.tab", header=T)
dim(nems3)
# Remove "Sample" from name
new <- sub("sample.","",names(nems3))
names(nems3) <- new
# Only take relevant data
nem2 <- nems3[,c(15,31:694)]
# Transpose
tpose <- t(nem2)
names(tpose) <- tpose[1,]
tpose <- tpose[-1,]
new2 <- strsplit(row.names(tpose), c("_"))
b <- unlist(new2)
meta2 <- matrix(b, ncol=3,byrow=T)
meta <- read.csv("meta_log3.csv")
tpose2 <- cbind(meta,tpose)
d <- read.csv("with_names.csv")
row.names(tpose)
invert2 <- cbind(tpose2, row.names(tpose2))
names(invert2)[334] <- "Sample"
Sample <- sub("sample.","",as.character(invert2[,334]))
invert3 <- cbind(invert2,Sample)
head(invert3)
nameys <- c("Location", "Year", "Species", "Number",seq(1:329),"S","Sample")
colnames(invert3) <- nameys
invert3 <- as.data.frame(invert3)
sd <- read.csv("Sequenced_Samples_nem2018.csv")
head(sd)
easy <- sd[sd$Sample %in% invert3$Sample==T,]
sd[sd$Sample %in% invert3$Sample==F,5]
sd[sd$Sample %in% invert3$Sample==F,5]
head(easy)
head(invert3)
names(invert3)
names(easy)
# This takes a little while
spes <- left_join(easy,invert3, by="Sample")
head(spes)
# need to convert to numical values
spes2 <- apply(spes[16:345],2,as.numeric)
spes3 <- cbind(spes[,1:15],spes2)
View(spes3)
levels(spes3$Location)
#### Just do MPALA
summary(d$Species)
mpala_d <- d[d$Location=="MRC",]
summary(mpala_d$Species)
mpala_13 <- mpala_d[mpala_d$Species%in%c("Buffalo", "Cow", "Eland", "Elephant", "Giraffe", "Grants Gazelle", "Grevy's Zebra", "Grevys zebra", "Hartebeest", "Impala", "Plains zebra", "Warthog", "Waterbuck", "Oryx")]
head(mpala_13)
names(mpala_13)
mpala_13$TOTAL <- apply(mpala_13[,6:273], 1, sum)
mp_std <- mpala_13 %>%
mutate_at(vars(V1:V325), funs(./TOTAL))
mp_sparse <- mp_std %>%
mutate_at(vars(V1:V325), funs(ifelse(.<0.05,0,.)))
mp_sparse$S2 <- specnumber(mp_sparse[,6:273])
length(which(colSums(mp_sparse[,6:273])==0))
mpzeros <- names(mp_sparse)[(which(colSums(mp_sparse[,6:271])==0)+5)]
# Condense dataset
mp_sparse2 <- mp_sparse[,-which(names(mp_sparse)%in%mpzeros)]
dim(mp_sparse2)
head(mp_sparse2)
mpassoc <- aggregate(.~Species,data=mp_sparse2[,c(5:46)], FUN=mean)
mpassoc
detach("package:vegan3d", unload=TRUE)
library("vegan3d", lib.loc="~/R/win-library/3.5")
library("igraph")
graph_from_adjacency_matrix(mpassoc)
as.matrix(mpassoc)
mp_mat <- as.matrix(mpassoc)
graph_from_adjacency_matrix(mp_mat)
crossprod(as.matrix(mp_mat[-1]))
str(mp_mat)
dim(mp_mat)
mp <- apply(mp_mat[,2:42], 1, as.numeric)
str(mp)
crossprod(as.matrix(mp[-1]))
mp_mat <- as.data.frame(mpassoc)
graph_from_data_frame(mp_mat)
map <- graph_from_data_frame(mp_mat)
plot(map)
map <- graph_from_incidence_matrix(mp_mat)
plot(map)
map <- graph_from_incidence_matrix(t(mp_mat))
plot(map)
View(mpassoc)
library(reshape2)
mp_mat2 <- gather(mp_mat, key=OTU, value=Reads, -Species)
head(mp_mat2)
dat2 <- melt(mp_mat2)
w <- dcast(dat2, Species~OTU)
x <- as.matrix(w[,-1])
x[is.na(x)] <- 0
x <- apply(x, 2,  function(x) as.numeric(x > 0))  #recode as 0/1
v <- x %*% t(x)                                   #the magic matrix
diag(v) <- 0                                      #repalce diagonal
dimnames(v) <- list(w[, 1], w[,1])                #name the dimensions
v
levels(mp_mat2$Species)
levels(mp_mat2$Species)[11] <- "Grevys zebra"
dat2 <- melt(mp_mat2)
w <- dcast(dat2, Species~OTU)
x[is.na(x)] <- 0
x <- apply(x, 2,  function(x) as.numeric(x > 0))  #recode as 0/1
v <- x %*% t(x)                                   #the magic matrix
diag(v) <- 0                                      #repalce diagonal
dimnames(v) <- list(w[, 1], w[,1])                #name the dimensions
dat2 <- melt(mp_mat2)
w <- dcast(dat2, Species~OTU)
x <- as.matrix(w[,-1])
x[is.na(x)] <- 0
x <- apply(x, 2,  function(x) as.numeric(x > 0))  #recode as 0/1
v <- x %*% t(x)                                   #the magic matrix
diag(v) <- 0                                      #repalce diagonal
dimnames(v) <- list(w[, 1], w[,1])                #name the dimensions
v
mp_mat2 <- gather(mp_mat, key=OTU, value=Reads, -Species)
levels(mp_mat2$Species)[11] <- "Grevys zebra"
dat2 <- melt(mp_mat2)
w <- dcast(dat2, Species~OTU)
x <- as.matrix(w[,-1])
x[is.na(x)] <- 0
x <- apply(x, 2,  function(x) as.numeric(x > 0))  #recode as 0/1
v <- x %*% t(x)                                   #the magic matrix
diag(v) <- 0                                      #repalce diagonal
dimnames(v) <- list(w[, 1], w[,1])                #name the dimensions
v
mp_mat2 <- gather(mp_mat, key=OTU, value=Reads, -Species)
#levels(mp_mat2$Species)[11] <- "Grevys zebra"
#library(reshape2)
dat2 <- melt(mp_mat2)
w <- dcast(dat2, Species~OTU)
x <- as.matrix(w[,-1])
x[is.na(x)] <- 0
x <- apply(x, 2,  function(x) as.numeric(x > 0))  #recode as 0/1
v <- x %*% t(x)                                   #the magic matrix
diag(v) <- 0                                      #repalce diagonal
dimnames(v) <- list(w[, 1], w[,1])                #name the dimensions
v
levels(mp_sparse2$Species)
levels(mp_sparse2$Species)[11] <- "Grevys zebra"
mpassoc <- aggregate(.~Species,data=mp_sparse2[,c(5:46)], FUN=mean)
mp_mat <- as.data.frame(mpassoc)
mp_mat2 <- gather(mp_mat, key=OTU, value=Reads, -Species)
dat2 <- melt(mp_mat2)
w <- dcast(dat2, Species~OTU)
x <- as.matrix(w[,-1])
x[is.na(x)] <- 0
x <- apply(x, 2,  function(x) as.numeric(x > 0))  #recode as 0/1
v <- x %*% t(x)                                   #the magic matrix
diag(v) <- 0                                      #repalce diagonal
dimnames(v) <- list(w[, 1], w[,1])                #name the dimensions
v
g <- graph.adjacency(v, weighted=TRUE, mode ='undirected')
g <- simplify(g)
# set labels and degrees of vertices
V(g)$label <- V(g)$name
V(g)$degree <- degree(g)
plot(g)
mpala_13 <- mpala_d[mpala_d$Species%in%c("Buffalo", "Cow", "Eland", "Elephant", "Giraffe", "Grants Gazelle", "Grevy's Zebra", "Grevys zebra", "Hartebeest", "Impala", "Plains zebra", "Warthog", "Waterbuck", "Oryx")]
head(mpala_13)
mpala_13$TOTAL <- apply(mpala_13[,6:273], 1, sum)
mp_std <- mpala_13 %>%
mutate_at(vars(V1:V325), funs(./TOTAL))
mp_sparse <- mp_std %>%
mutate_at(vars(V1:V325), funs(ifelse(.<0.05,0,.)))
mp_sparse$S2 <- specnumber(mp_sparse[,6:273])
# How many OTUs have <5%?
length(which(colSums(mp_sparse[,6:273])==0))
mpzeros <- names(mp_sparse)[(which(colSums(mp_sparse[,6:271])==0)+5)]
# Condense dataset
mp_sparse2 <- mp_sparse[,-which(names(mp_sparse)%in%mpzeros)]
dim(mp_sparse2)
levels(mp_sparse2$Species)[11] <- "Grevys zebra"
levels(mp_sparse2$Species)
droplevels(mp_sparse2$Species)
mpassoc <- aggregate(.~Species,data=mp_sparse2[,c(5:46)], FUN=mean)
levels(mpassoc)
levels(mpassoc$Species)
mpassoc <- mpassoc[which(mpassoc$Species %in% c("Buffalo", "Cow", "Eland", "Elephant", "Giraffe", "Grants Gazelle", "Grevy's Zebra", "Grevys zebra", "Hartebeest", "Impala", "Plains zebra", "Warthog", "Waterbuck", "Oryx")),]
mp_mat <- as.data.frame(mpassoc)
mp_mat2 <- gather(mp_mat, key=OTU, value=Reads, -Species)
dat2 <- melt(mp_mat2)
w <- dcast(dat2, Species~OTU)
x <- as.matrix(w[,-1])
x[is.na(x)] <- 0
x <- apply(x, 2,  function(x) as.numeric(x > 0))  #recode as 0/1
v <- x %*% t(x)                                   #the magic matrix
diag(v) <- 0                                      #repalce diagonal
dimnames(v) <- list(w[, 1], w[,1])                #name the dimensions
v
g <- graph.adjacency(v, weighted=TRUE, mode ='undirected')
g <- simplify(g)
# set labels and degrees of vertices
V(g)$label <- V(g)$name
V(g)$degree <- degree(g)
plot(g)
g <- graph.adjacency(v, weighted=TRUE, mode ='undirected')
plot(g)
plot(g)
g <- simplify(g)
plot(g)
E(g)$width <- E(g)$weight
plot(g)
E(g)$width <- E(g)$weight/6
plot(g)
E(g)$width <- E(g)$weight/6=3
E(g)$width <- E(g)$weight/3
plot(g)
E(g)$width <- E(g)$weight
plot(g)
E(g)$width <- E(g)$weight/2
plot(g)
mpassoc
colSums(mpassoc[,-1])
mp_bin <- mutate_at(mpassoc, vars(V1:V325), funs(ifelse(.>0,1,0))
mp_bin <- mutate_at(mpassoc, vars(V1:V325), funs(ifelse(.>0,1,0)))
mp_bin <- mutate_at(mpassoc, vars(V1:V325), funs(ifelse(.>0,1,0)))
mp_bin
colSums(mpassoc[,-1])
hist(colSums(mpassoc[,-1]))
colSums(mpassoc[,-1])
hist(colSums(mp_bin[,-1]))
colSums(mp_bin[,-1])
length(which(colSums(mp_bin[,-1])%in%c(1,2)))
length(which(colSums(mp_bin[,-1])>0))
21/36
length(which(colSums(mp_bin[,-1])<5))
length(which(colSums(mp_bin[,-1])>5))
mp_mat
mp_matb <- mp_mat[,-2]
mp_mat2 <- gather(mp_matb, key=OTU, value=Reads, -Species)
#library(reshape2)
dat2 <- melt(mp_mat2)
w <- dcast(dat2, Species~OTU)
x <- as.matrix(w[,-1])
x[is.na(x)] <- 0
x <- apply(x, 2,  function(x) as.numeric(x > 0))  #recode as 0/1
v <- x %*% t(x)                                   #the magic matrix
diag(v) <- 0                                      #repalce diagonal
dimnames(v) <- list(w[, 1], w[,1])                #name the dimensions
v
g <- graph.adjacency(v, weighted=TRUE, mode ='undirected')
g <- simplify(g)
# set labels and degrees of vertices
V(g)$label <- V(g)$name
V(g)$degree <- degree(g)
E(g)$width <- E(g)$weight/2
plot(g)
mpassoc
mp_bin <- mutate_at(mpassoc, vars(V1:V325), funs(ifelse(.>0,1,0)))
mp_bin
hist(colSums(mp_bin[,-1]))
length(which(colSums(mp_bin[,-1])%in%c(1,2)))
length(which(colSums(mp_bin[,-1])>5))
mp_bin
mp_mat2
v
load("D:/Dropbox/Projects/Watering Holes/Presentations/TWS/Work_in_progress.RData")
str(final)
otu <- read.csv("with_names.csv")
levels(otu$Location)
dim(otu)
head(oty)
head(otu)
