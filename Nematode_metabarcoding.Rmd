---
title: "Nematode_Metabarcoding"
author: "Georgia Titcomb"
date: "April 25, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(vegan)
library(tidyverse)
library(dplyr)
library(gridExtra)
```

# 1. Import data

```{r cars}
otus <- read.csv("with_names.csv")

tab3 <- read.table("OTU_log3.tab", header=T)
dim(tab3)
# This is the other OTU table based on different filtering thresholds
#tab35 <- read.table("OTU_log3.5.tab")
#dim(tab35)
```

# 2. Read summary

```{r}
# average reads per sample
summary(colSums(tab3[31:694]))

par(mfrow=c(1,2))

hist(colSums(tab3[31:694]), main="Distribution of reads per sample")
hist(log(colSums(tab3[31:694])), main="Distribution of log(reads per sample)")
min(colSums(tab3[31:694]))
max(colSums(tab3[31:694]))

```

The mean number of reads per sample is a little over 15,000, but with a median over ~10,000. There are quite a lot of OTUs per sample, so we need to standardize and filter out very rare reads that are likely to be errors.

# 3. Rarefaction and RRA

The first step is to rarefy the data. The minimum number of reads per sample is 533 -- this seems quite low compared to Pansu et al (2018), and the histogram shows that samples more commonly are in the order of ~1000 reads.

```{r}

rare_nem2 <- rrarefy(t(tab3[,31:694]), sample=533)
length(which(colSums(tab3[31:694])<1000)) # only one sample affected

```


The next step is to calculate the relative read abundance (RRA) - defined in Pansu 2018 as the proportional read abundance of a given OTU within each sample.

```{r}

rare_nem2 <- as.data.frame(rare_nem2)

# Divide by the number of reads per sample to get the relative read abundance
rare_nem2_RRA <- rare_nem2 %>%
  mutate_at(vars(V1:V329), funs(./533))

```

Now create two datasets that filter out very low abundance reads (1% and 5%).

```{r}

rare_nem2_RRA_1pct <- rare_nem2_RRA %>%
  mutate_at(vars(V1:V329), funs(ifelse(.>0.01,.,0)))
rownames(rare_nem2_RRA_1pct) <- names(tab3)[31:694]
# recombine
rare_nem2_RRA_1pct <- cbind(tab3[,1:30],t(rare_nem2_RRA_1pct))
# remove empty OTU rows
rare_nem2_RRA_1pct <- rare_nem2_RRA_1pct[-which(rowSums(rare_nem2_RRA_1pct[,31:694])==0),]
dim(rare_nem2_RRA_1pct)


rare_nem2_RRA_5pct <- rare_nem2_RRA %>%
  mutate_at(vars(V1:V329), funs(ifelse(.>0.05,.,0)))
rownames(rare_nem2_RRA_5pct) <- names(tab3)[31:694]
rare_nem2_RRA_5pct <- cbind(tab3[,1:30],t(rare_nem2_RRA_5pct))

rare_nem2_RRA_5pct <- rare_nem2_RRA_5pct[-which(rowSums(rare_nem2_RRA_5pct[,31:694])==0),]
dim(rare_nem2_RRA_5pct)

```

When the threshold is 1%, we get 99 OTUs for 664 samples. When it is 5%, we get 73 OTUs.


# 3. Comparison to Matt's FECs

```{r}
# add metadata to RRA df

FECs <- read.csv("FEC_comparison.csv")

ggplot(FECs, aes(x=Reads, y=FEC))+
  geom_point()

```

Raw data shows one point where we have reads but FEC is 0. However, this is before filtering. Recombining the dataset using the 5 percent cutoff threshold:

```{r}

FECs$sample2 <- paste("sample.",FECs$Sample, sep="")
names(rare_nem2_RRA_5pct)[31:694] <- str_pad(names(rare_nem2_RRA_5pct)[31:694],3,pad="0")

#rare_nem2_RRA_5pct[,(which(names(rare_nem2_RRA_5pct) %in% FECs$sample2))]
# Assuming that the ones that are False are 0 reads

b <- as.data.frame(colSums(rare_nem2_RRA_5pct[,(which(names(rare_nem2_RRA_5pct) %in% FECs$sample2))]))
b$sample2 <- rownames(b)
names(b) <- c("RRAtot","sample2")

joined_df <- left_join(FECs, b, by="sample2")

joined_df <- joined_df %>%
  mutate_at(vars(RRAtot), funs(ifelse(is.na(.)==T,0,.)))

ggplot(joined_df, aes(x=FEC, y=RRAtot))+
  geom_point(aes(color=log(Reads+1)), size=2)+
  ggtitle("FECs vs Sequencing using 5% cutoff threshold")


```

We get a similar result, with one sample having reads and no FEC count. However, it is notatble that the RRAtotal is lower than the rest, indicating a lot of low quality reads that got filtered  out.
I'm not sure exactly what to do with this sample.

Using the 1% threshold:

```{r}

FECs$sample2 <- paste("sample.",FECs$Sample, sep="")
names(rare_nem2_RRA_1pct)[31:694] <- str_pad(names(rare_nem2_RRA_1pct)[31:694],3,pad="0")

#rare_nem2_RRA_5pct[,(which(names(rare_nem2_RRA_5pct) %in% FECs$sample2))]
# Assuming that the ones that are False are 0 reads

b <- as.data.frame(colSums(rare_nem2_RRA_1pct[,(which(names(rare_nem2_RRA_1pct) %in% FECs$sample2))]))
b$sample2 <- rownames(b)
names(b) <- c("RRAtot","sample2")

joined_df <- left_join(FECs, b, by="sample2")

joined_df <- joined_df %>%
  mutate_at(vars(RRAtot), funs(ifelse(is.na(.)==T,0,.)))

ggplot(joined_df, aes(x=FEC, y=RRAtot))+
  geom_point(aes(color=log(Reads+1)), size=2)+
  ggtitle("FECs vs Sequencing using 1% cutoff threshold")

dim(joined_df)

```

## OTU results

```{r}
# looking at genus:
p1 <- ggplot(rare_nem2_RRA_1pct, aes(x=reorder(family_name, -table(family_name)[family_name])))+
  geom_bar(aes(fill=genus_name))+
  theme(axis.text.x=element_text(angle=90, hjust=1))+
  xlab("Family Name")+
  ggtitle("1% threshold")

# and 5%
p2 <- ggplot(rare_nem2_RRA_5pct, aes(x=reorder(family_name, -table(family_name)[family_name])))+
  geom_bar(aes(fill=genus_name))+
  theme(axis.text.x=element_text(angle=90, hjust=1))+
  xlab("Family Name")+
  ggtitle("5% threshold")

grid.arrange(p1, p2, ncol=2)


```

These are mostly similar; however we can see that there are more "none" IDs relative to other IDs when using the 1% cutoff threshold. Additionally, there are more Protostrongylidae records when 1% is used.

# Results within species and locations

Now we need to combine the RRA tables with the appropriate metadata.

```{r}
# I will do this using the species ID and names
# transpose
RRA_t_5 <- as.data.frame(t(rare_nem2_RRA_5pct[,31:694]))
# remove "sample"
RRA_t_5$sampleID <- sub("sample.",replacement="",x=rownames(RRA_t_5))

# bring in metadata
metadata <- read.csv("Sequenced_Samples_nem2018.csv")

length(which(metadata$Sample %in% RRA_t_5$sampleID == F))
length(which(metadata$Sample %in% RRA_t_5$sampleID == T))

# edit sample names to make sure they match up
RRA_t_5$sampleID2 <- sub("MRC_",replacement="", x=RRA_t_5$sampleID)
RRA_t_5$sampleID2 <- sub("PNG_16", replacement="PNG16", x=RRA_t_5$sampleID2)
RRA_t_5$sampleID2 <- sub("PNG_15", replacement="JAG15", x=RRA_t_5$sampleID2)

#RRA_t_5$sampleID2[which(RRA_t_5$sampleID2 %in% metadata$sampleID == F)]

# rename so that joining column name matches
names(metadata)[5] <- "sampleID2"

RRA_5_join <- left_join(metadata, RRA_t_5)
length(which(is.na(RRA_5_join$V1)))



# Repeat this for the 1%
# transpose
RRA_t_1 <- as.data.frame(t(rare_nem2_RRA_1pct[,31:694]))
# remove "sample"
RRA_t_1$sampleID <- sub("sample.",replacement="",x=rownames(RRA_t_1))

length(which(metadata$Sample %in% RRA_t_1$sampleID == F))
length(which(metadata$Sample %in% RRA_t_1$sampleID == T))

# edit sample names to make sure they match up
RRA_t_1$sampleID2 <- sub("MRC_",replacement="", x=RRA_t_1$sampleID)
RRA_t_1$sampleID2 <- sub("PNG_16", replacement="PNG16", x=RRA_t_1$sampleID2)
RRA_t_1$sampleID2 <- sub("PNG_15", replacement="JAG15", x=RRA_t_1$sampleID2)

#RRA_t_1$sampleID2[which(RRA_t_1$sampleID2 %in% metadata$sampleID2 == F)]

RRA_1_join <- left_join(metadata, RRA_t_1)

length(which(is.na(RRA_1_join$V1)))


```

Check out the new data:
```{r}
head(RRA_5_join)
RRA_5_join %>% 
  group_by(Species) %>% 
  ggplot(aes(x=Species, y=V1)) + geom_point() + geom_boxplot(alpha=0.2) + theme(axis.text.x=element_text(angle=90, hjust=1)) + ggtitle("OTU 1 RRA by host species (5%)")

RRA_1_join %>% 
  group_by(Species) %>% 
  ggplot(aes(x=Species, y=V1)) + geom_point() + geom_boxplot(alpha=0.2) + theme(axis.text.x=element_text(angle=90, hjust=1)) + ggtitle("OTU 1 RRA by host species (1%)")
```

Now some network graphs

```{r}
samp_mat_1 <- RRA_1_join %>% group_by(Species) %>% summarize_at(vars(V1:V302), funs(mean(., na.rm=T)))

samp_mat_1 <- samp_mat_1[-which(samp_mat_1$Species %in% c("Primer", "POS", "NEG")),]
levelplot(as.matrix(samp_mat_1[,-1]),  col.regions = gray(0:100/100))

# need to put all in one column
mat_1_long <- gather(samp_mat_1, key=OTU, value=RRA, -Species)

# remove zeros
mat_1_long <- mat_1_long[-which(mat_1_long$RRA == 0),]


# now do this for individuals
imat_1_long <- gather(RRA_1_join[,11:111], key=OTU, value=RRA, -Species)
imat_1_long <- imat_1_long[-which(imat_1_long$Species %in% c("Primer", "POS", "NEG"))]
imat_1_long <- imat_1_long[-which(imat_1_long$RRA == 0),]
imat_1_long <- imat_1_long[-which(is.na(imat_1_long$RRA)),]
dim(imat_1_long)
imat_1_long

library(igraph)
g <- graph.data.frame(mat_1_long, directed=FALSE)

V(g)$type <- bipartite_mapping(g)$type 
V(g)$color <- ifelse(V(g)$type, "lightblue", "salmon")
V(g)$shape <- ifelse(V(g)$type, "square", "circle")
E(g)$color <- "lightgray"
V(g)$frame.color <-  "white"
V(g)$label.dist <-1.3

  
plot(g, vertex.label.cex = 0.8, vertex.label.color = "black")
plot(g, layout=layout.bipartite, vertex.size=2, vertex.label.cex=0.8)

### Individual

g <- graph.data.frame(imat_1_long, directed=FALSE)
V(g)$type <- bipartite_mapping(g)$type 
V(g)$color <- ifelse(V(g)$type, "lightblue", "salmon")
V(g)$shape <- ifelse(V(g)$type, "square", "circle")
E(g)$color <- "lightgray"
V(g)$frame.color <-  "white"
V(g)$label.dist <-1.3

  
plot(g, vertex.label.cex = 0.8, vertex.label.color = "black")
plot(g, layout=layout.bipartite, vertex.size=2, vertex.label.cex=0.8)


library(bipartite)
tsamp_mat_1 <- as.data.frame(t(samp_mat_1[,-1]))
dim(tsamp_mat_1)
names(tsamp_mat_1) <- samp_mat_1$Species
plotweb(tsamp_mat_1, high.spacing=NULL, col.interaction=rep(1:20),bor.col.interaction=rep(1:20), col.high=rep(1:20), high.lablength=3)
#plotweb(RRA_1_join[,12:111])

#visualized the other way
row.names(samp_mat_1)
row.names(samp_mat_1b) <- samp_mat_1$Species
samp_mat_1b <- as.data.frame(samp_mat_1[,-1])
row.names(samp_mat_1b) <- samp_mat_1$Species
plotweb(samp_mat_1b)

```

Now doing the same for the 5% cutoff

```{r}

samp_mat_5 <- RRA_5_join %>% group_by(Species) %>% summarize_at(vars(V1:V267), funs(mean(., na.rm=T)))

samp_mat_5 <- samp_mat_5[-which(samp_mat_5$Species %in% c("Primer", "POS", "NEG")),]
levelplot(as.matrix(samp_mat_5[,-1]),  col.regions = gray(0:100/100))

# need to put all in one column
mat_5_long <- gather(samp_mat_5, key=OTU, value=RRA, -Species)

# remove zeros
mat_5_long <- mat_5_long[-which(mat_5_long$RRA == 0),]

g2 <- graph.data.frame(mat_5_long, directed=FALSE)

V(g2)$type <- bipartite_mapping(g2)$type 
V(g2)$color <- ifelse(V(g2)$type, "lightblue", "salmon")
V(g2)$shape <- ifelse(V(g2)$type, "square", "circle")
V(g2)$frame.color <-  "white"
V(g2)$label.dist <-1.3
length(V(g2)$name)
length(E(g2))
(E(g2)[[1:286]])

deets <- read.delim("D:/Dropbox/Projects/Watering Holes/Data_all/Genetics/Analysis2/Rwork_nems/nem_data/edge_details_5.txt", header=FALSE)
names(deets) <- c("rowID","Species","head","tid", "hid", "RRA", "color")
head(deets)

E(g2)$color <- as.factor(deets$Species)
V(g2)$color <- as.factor(V(g2)$name)
  
plot(g2, vertex.label.cex = 0.8, vertex.label.color = "black")
plot(g2, layout=layout.bipartite, vertex.size=2, vertex.label.cex=0.8)
```

### Following the igraph tutorial on network analysis, option 1: regarding as one mode

```{r}
### 1% dataset
types <- V(g)$type                 ## getting each vertex `type` let's us sort easily
deg <- degree(g)
bet <- betweenness(g)
clos <- closeness(g)
eig <- eigen_centrality(g)$vector

cent_df <- data.frame(types, deg, bet, clos, eig)

cent_df[order(cent_df$type, decreasing = TRUE),] ## sort w/ `order` by `type`

V(g)$size <- degree(g) *0.2
V(g)$label.cex <- degree(g) * 0.01

plot(g, layout = layout_with_graphopt)


### 5% dataset
types <- V(g2)$type                 ## getting each vertex `type` let's us sort easily
deg <- degree(g2)
bet <- betweenness(g2)
clos <- closeness(g2)
eig <- eigen_centrality(g2)$vector

cent_df2 <- data.frame(types, deg, bet, clos, eig)

cent_df2[order(cent_df2$type, decreasing = TRUE),] ## sort w/ `order` by `type`

V(g2)$size <- degree(g2)*0.5
V(g2)$label.cex <- degree(g2) * 0.02

plot(g2, layout = layout_with_graphopt)

just_animals_5 <- cent_df2[which(row.names(cent_df2) %in% c("Buffalo","Bushbuck","Camel","Cow","Dik-dik","Eland","Elephant","Giraffe","Grants Gazelle","Grevys zebra","Hartebeest","Hippo","Hybrid zebra","Impala","Kudu","Oryx","Plains zebra","Waterbuck","Warthog","Donkey")),]

just_animals_5$Species <- row.names(just_animals_5)
# what is the sample size for each species?
count <- RRA_5_join %>% group_by(Species) %>% summarize_at(vars(V1), funs(n()))
names(count)[2] <- "count"
just_animals_5 <- left_join(just_animals_5,count)
just_animals_5
car::scatterplotMatrix(just_animals_5[,c(2:5,7)])

# Now need to account for unequal sample sizes....
```

### Option 2: analyzing separately

```{r}
library(tnet)
tm<-get.edgelist(g, names=FALSE)

head(tm)  # check to make sure it worked
NodeLabels <- V(g)$name

head(NodeLabels)   # Again, check

mt <- tm[, c(2, 1)]

head(mt) 

deg_tm <- degree_tm(tm)

deg_mt <- degree_tm(mt)

deg_tm
deg_mt

# I don't really understand this method
```

### Option 3: convert 2 mode to 1 mode

```{r}

bipartite_matrix <- as_incidence_matrix(g)
event_matrix_prod <- t(bipartite_matrix) %*% bipartite_matrix 
## crossprod() does same and scales better, but this is better to learn at first at first so you understand the method
diag(event_matrix_prod) <- 0
event_matrix_prod
person_matrix_prod <- bipartite_matrix %*% t(bipartite_matrix)
diag(person_matrix_prod) <- 0
person_matrix_prod
women_overlap <- graph_from_adjacency_matrix(person_matrix_prod, 
                                        mode = "undirected", 
                                        weighted = TRUE)

women_overlap

events_overlap <- graph_from_adjacency_matrix(event_matrix_prod, 
                                       mode = "undirected", 
                                       weighted = TRUE)

events_overlap

E(women_overlap)$weight
E(events_overlap)$weight
```

### Simple matching

```{r}
library(ade4)

bipartite_matrix <- as_incidence_matrix(g)  # Extract the matrix

women_match <- dist.binary(bipartite_matrix, method=2, upper=TRUE, diag = FALSE) # Method #2 is "simple matching"
event_match <- dist.binary(t(bipartite_matrix), method=2, upper=TRUE, diag = FALSE) # Method #2 is "simple matching"

women_match <- as.matrix(women_match)
matching_women <- ifelse(women_match>0.6, 1, 0)
matching_women

match_women <- graph_from_adjacency_matrix(matching_women, 
                                        mode = "undirected")
plot(match_women)

```

### Jaccard similarity

```{r}

bipartite_matrix <- as_incidence_matrix(g)  # Extract the matrix

women_jaccard <- dist.binary(bipartite_matrix, method=1, upper=TRUE, diag = FALSE) # Method #1 is "Jaccard Index"
event_jaccard <- dist.binary(t(bipartite_matrix), method=1, upper=TRUE, diag = FALSE) 

women_jaccard <- as.matrix(women_jaccard)   
diag(women_jaccard)<-0

#women_jaccard          # Look at the matrix before you binarize
jaccard_women <- ifelse(women_jaccard>0.90, 1, 0)     # Binarize

# jaccard_women      # Take a look at the matrix if you like.

jacc_women <- graph_from_adjacency_matrix(jaccard_women,    # Create an igraph network
                                        mode = "undirected")
plot(jacc_women)



```

### Pearson's correlation

```{r}
bipartite_matrix <- as_incidence_matrix(g)  # Extract the matrix

women_correl <- cor(t(bipartite_matrix))
event_correl <- cor(bipartite_matrix)

women_correl <- as.matrix(women_correl)   
# women_correl          # Look at the matrix before you binarize
correl_women <- ifelse(women_correl>0.5, 1, 0)    # Binarize 
diag(correl_women)<-0
# correl_women    # Take a look at the matrix if you like


corr_women <- graph_from_adjacency_matrix(correl_women,     # Create an igraph network
                                        mode = "undirected")
plot(corr_women)



```



### Phylogenetic signal


```{r}
library(phylosignal)
library(adephylo)
library(ape)
library(phylobase)
data(carni19)

carni19$bm
carni19$tre
tre <- read.tree(text=carni19$tre)
dat <- list()
dat$mass <- carni19$bm
dat$random <- rnorm(19, sd = 10)
dat$bm <- rTraitCont(tre)
dat <- as.data.frame(dat)

p4d <- phylo4d(tre, dat)
barplot.phylo4d(p4d, tree.type = "phylo", tree.ladderize = TRUE)


tree <- read.tree("mammaltree.txt")
plot(tree)

# Then each trait could be mean RRA for each species
head(samp_mat_1)
samp_mat_1$SciName <- c("Syncerus_caffer","Tragelaphus_scriptus","Camelus_dromedarius","Bos_taurus","Madoqua_kirkii", "Equus_asinus", "Taurotragus_oryx", "Loxodonta_africana", "Giraffa_camelopardalis", "Gazella_granti", "Equus_grevyi", "Alcelaphus_buselaphus", "Hybrid", "Hippopotamus_amphibius", "Aepyceros_melampus", "Tragelaphus_strepsiceros", "Oryx_gazella", "Equus_buchelli", "Phacochoerus_africanus", "Kobus_ellipsiprymnus")

samp_mat_1c <- samp_mat_1[-which(samp_mat_1$Species == "Hybrid zebra"),]
dim(samp_mat_1c)
mamms <- samp_mat_1c[,c(101,2:10)]

p4d2 <- phylo4d(tree, mamms)

tree2 <- collapse.singles(tree)
plot(tree2)
p4d2 <- phylo4d(tree2, mamms)


barplot.phylo4d(p4d, tree.type = "phylo", tree.ladderize = TRUE)
barplot.phylo4d(p4d2[,-1], tree.type="phylo", tree.ladderize=TRUE)

```
